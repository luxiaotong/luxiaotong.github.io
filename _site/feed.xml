<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Shannon Lu</title>
    <description>This is my blog about tech</description>
    <link></link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Redis与Memcached的区别</title>
        <description>&lt;h2&gt;持久化&lt;/h2&gt;

&lt;hr&gt;

&lt;h3&gt;RDB(快照)&lt;/h3&gt;

&lt;h4&gt;优点&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;RDB会把某一时间点的在redis的数据压缩到单个文件中，在实际中，可以获取过去24小时中每个小时的RDB文件，也可以每天保存。灾难恢复时很容易的使用不同版本恢复&lt;/li&gt;
&lt;li&gt;RDB非常适合容灾，单个压缩文件可以传到远程数据中心&lt;/li&gt;
&lt;li&gt;RDB最大化了Redis性能，Redis主线程fork子进程然后其它事情由子进程处理，主进程不处理磁盘IO操作&lt;/li&gt;
&lt;li&gt;RDB在重启大数据集时，速度更快&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;缺点&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;数据丢失：如果希望在redis挂掉时尽可能少的丢数据，RDB是不合适的。可以配置不同的保存点（至少5分钟且有100次数据写入，可以有多个保存点），每5分钟或更多时间会有一次快照，但是如果redis非正常原因停止工作，会丢失最近的数据。&lt;/li&gt;
&lt;li&gt;时间消耗：Redis为了持久化到磁盘，需要经常fork子进程。如果数据很大，fork会很消耗时间，可能会导致redis停止服务几微秒，如果数据非常大而且cpu不给力可能会有1秒。虽然AOF也需要fork，但是你可以调整重写Log的频率，且在执行期间不带有额外开销&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;AOF(记录每一次写操作)&lt;/h3&gt;

&lt;h4&gt;优点：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;使用AOF，Redis更持久：可以使用不同的文件同步策略，不同步、每秒同步、每次请求同步。默认策略每秒同步性能也很好（fsync使用一个后台线程实现，而没有fsync执行时，主线程尽可能执行写操作），最多丢一秒的数据。&lt;/li&gt;
&lt;li&gt;AOF是只追加型的日志，所以断电时，不会丢数据。就算是日志结尾写入一半（磁盘满），仍然可以使用redis-check-aof轻松修复。&lt;/li&gt;
&lt;li&gt;当AOF太大时Redis可以在后台自动重写，重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。。重写是完全安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 * AOF 文件进行追加操作。&lt;/li&gt;
&lt;li&gt;AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂，对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单：举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写，那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令，并重启 Redis ，就可以将数据集恢复到 FLUSHALL 执行之前的状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;缺点：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。&lt;/li&gt;
&lt;li&gt;根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）
可以禁用持久化
结合使用
如何选择
一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。
如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。
有很多用户都只使用 AOF 持久化， 但我们并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。
当 Redis 启动时， 如果 RDB 持久化和 AOF 持久化都被打开了， 那么程序会优先使用 AOF 文件来恢复数据集， 因为 AOF 文件所保存的数据通常是最完整的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;数据结构&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;Memcache: kv&lt;/p&gt;

&lt;p&gt;Redis: kv, hashes, lists, sets, sorted sets&lt;/p&gt;

&lt;h2&gt;过期&lt;/h2&gt;

&lt;hr&gt;

&lt;h4&gt;Memcache&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;访问Key的时候，发现超时，标识删除为1&lt;/li&gt;
&lt;li&gt;不会真正删除分配的内存，覆盖新的key&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Redis&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;积极方式 当访问key的时候，会发现是否超时&lt;/li&gt;
&lt;li&gt;消积方式 定期随机检测若干个key，如果过期则删除。每秒执行10次如下操作：在设置过期时间的key中随机检测20个key，删除过期的key，如果超过25%的key被删除，再执行一遍&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;LRU&lt;/h2&gt;

&lt;hr&gt;

&lt;h3&gt;设置最大内存&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;可以在配置文件中设置 也可以用命令设置&lt;/li&gt;
&lt;li&gt;设置0表示没有内存限制&lt;/li&gt;
&lt;li&gt;到达指定内存时，会有不同的处理行为，即策略。如报错，清理旧数据等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;回收策略&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;noeviction 不回收，直接报错&lt;/li&gt;
&lt;li&gt;allkeys-lru 优先回收最近很少使用的key 为新数据增加空间&lt;/li&gt;
&lt;li&gt;volatile-lru 优先回收最近很少使用的【且设置超时的】key&lt;/li&gt;
&lt;li&gt;allkeys-random 所有key中随机回收&lt;/li&gt;
&lt;li&gt;volatile-random 在设置超时的key中随机回收&lt;/li&gt;
&lt;li&gt;volatile-ttl 回收最近很少使用的【且设置超时的】key 且优先回收存活时间短的&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Redis实现&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;allkeys和volatile分别在两个table中&lt;/li&gt;
&lt;li&gt;random则直接随机取出若干个&lt;/li&gt;
&lt;li&gt;LRU的实现是近似LRU。之前版本实现：随机找三条记录出来，比较哪条空闲时间最长就删哪条，然后再随机三条出来，一直删到内存足够放下新记录为止。3.0版本实现：现在每次随机五条记录出来，插入到一个长度为十六的按空闲时间排序的队列里，然后把排头的那条删掉，然后再找五条出来，继续尝试插入队列。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Memcached实现&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;最大可设置2G内存&lt;/li&gt;
&lt;li&gt;LRU列队，双向链表&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;hr&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://redis.io/topics/persistence&quot;&gt;Redis Persistence&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://redis.io/topics/lru-cache&quot;&gt;Using Redis as an LRU cache&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.yidianzixun.com/08lZsltN?s=undefined&quot;&gt;LRU算法的实现，简单粗暴的Redis与中规中矩的Memcached&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/luotuo44/article/details/42869325&quot;&gt;memcached源码分析-----LRU队列与item结构体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://redis.io/topics/memory-optimization&quot;&gt;Using hashes to abstract a very memory efficient plain key-value store on top of Redis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.nosqlfan.com/html/3379.html&quot;&gt;节约内存：Instagram的Redis实践&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 13 Jul 2015 00:00:00 +0800</pubDate>
        <link>/Redis%E4%B8%8EMemcached%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
        <guid isPermaLink="true">/Redis%E4%B8%8EMemcached%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      </item>
    
      <item>
        <title>解决安装xhprof后 fpm报错问题(recv failed 104 nginx 502)</title>
        <description>&lt;h2&gt;问题描述&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;安装xhprof后，在代码中加入&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;xhprof_enable(XHPROF_FLAGS_CPU+XHPROF_FLAGS_MEMORY); 
$xhprof_data = xhprof_disable();
var_dump($xhprof_data);exit;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;通过浏览器访问出现nginx 502报错&lt;/strong&gt;
&lt;img src=&quot;http://luxiaotong-image.stor.sinaapp.com/nginx_502.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;nginx error log报错如下&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;2015/06/29 21:30:26 [error] 27710#0: *140 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 10.44.112.83, server: , request: &amp;quot;GET /test.php HTTP/1.1&amp;quot;, upstream: &amp;quot;fastcgi://127.0.0.1:8500&amp;quot;, host: &amp;quot;cq01-rdqa-dev091.cq01.baidu.com:8001&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;fpm log日志信息如下&lt;/strong&gt;
&lt;code&gt;
[29-Jun-2015 21:30:26] WARNING: [pool www2] child 27270 exited on signal 11 (SIGSEGV - core dumped) after 7526.184909 seconds from start
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;问题解决过程&lt;/h2&gt;

&lt;p&gt;首先从上述日志并没有看出具体的问题，经过在谷组上搜索，『recv failed 104 connection resetby peer』&lt;/p&gt;

&lt;p&gt;发现要在fpm日志输出更多错误信息。
&lt;a href=&quot;http://stackoverflow.com/questions/18379323/failed-104-connection-reset-by-peer&quot;&gt;方法如下&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;修改fpm配置文件fpm.conf，加入&lt;strong&gt;catch_workers_output = yes&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[global]
pid = run/fpm.pid
error_log = log/fpm.log
daemonize = yes 
[www2]
user=nobody
group=nobody
listen = ***
pm = dynamic
pm.max_children = 200 
pm.start_servers = 2 
pm.min_spare_servers = 1 
pm.max_spare_servers = 3 
request_terminate_timeout = 120s
rlimit_files = 1310
rlimit_core = unlimited
catch_workers_output = yes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重启fpm，再次请求，fpm log会输出如下信息&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;30-Jun-2015 19:02:20] WARNING: [pool www2] child 17892 said into stderr: &amp;quot;setaffinity: Invalid argument&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次在谷姐上搜索『setaffinity: Invalid argument』
找到在&lt;a href=&quot;https://bugs.php.net/bug.php?id=60078&quot;&gt;php bug中有对该问题的描述，以及对该问题的分析&lt;/a&gt;，并且在评论中找到&lt;a href=&quot;https://github.com/odoucet/xhprof/commit/2e74533746bf14b0bcfc9a6fae08e1bf9b4f724b&quot;&gt;修复此问题的代码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;于是&lt;strong&gt;将xhprof.c按照提交中的样子修改&lt;/strong&gt;一下，之后将xhprof重新编译安装，就可以正常运行了。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;array(2) {
  [&amp;quot;main()==&amp;gt;xhprof_disable&amp;quot;]=&amp;gt;
  array(5) {
    [&amp;quot;ct&amp;quot;]=&amp;gt;
    int(1)
    [&amp;quot;wt&amp;quot;]=&amp;gt;
    int(3)
    [&amp;quot;cpu&amp;quot;]=&amp;gt;
    int(0)
    [&amp;quot;mu&amp;quot;]=&amp;gt;
    int(840)
    [&amp;quot;pmu&amp;quot;]=&amp;gt;
    int(0)
  }
  [&amp;quot;main()&amp;quot;]=&amp;gt;
  array(5) {
    [&amp;quot;ct&amp;quot;]=&amp;gt;
    int(1)
    [&amp;quot;wt&amp;quot;]=&amp;gt;
    int(16)
    [&amp;quot;cpu&amp;quot;]=&amp;gt;
    int(0)
    [&amp;quot;mu&amp;quot;]=&amp;gt;
    int(1856)
    [&amp;quot;pmu&amp;quot;]=&amp;gt;
    int(0)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;参考文献&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/18379323/failed-104-connection-reset-by-peer&quot;&gt;http://stackoverflow.com/questions/18379323/failed-104-connection-reset-by-peer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://bugs.php.net/bug.php?id=60078&quot;&gt;https://bugs.php.net/bug.php?id=60078&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/odoucet/xhprof/commit/2e74533746bf14b0bcfc9a6fae08e1bf9b4f724b&quot;&gt;https://github.com/odoucet/xhprof/commit/2e74533746bf14b0bcfc9a6fae08e1bf9b4f724b&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 01 Jul 2015 00:00:00 +0800</pubDate>
        <link>/%E8%A7%A3%E5%86%B3%E5%AE%89%E8%A3%85xhprof%E5%90%8E%20fpm%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98(recv%20failed%20104%20nginx%20502)/</link>
        <guid isPermaLink="true">/%E8%A7%A3%E5%86%B3%E5%AE%89%E8%A3%85xhprof%E5%90%8E%20fpm%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98(recv%20failed%20104%20nginx%20502)/</guid>
      </item>
    
      <item>
        <title>2014总结</title>
        <description>&lt;h4&gt;关于读书&lt;/h4&gt;

&lt;hr&gt;

&lt;h5&gt;Freedom&lt;/h5&gt;

&lt;p&gt;今年很重要的一本书, 第一次读英文原版, 前后大概用了4个月. 书读起来很有意思, 但是从内容中并没有太多收获, 就不在这冗述了.
这本书中最重要的意义肯定是学英文了, 明显提高了阅读理解能力和阅读速度, 也增加了一定的词汇量. 从开始的2天读一页还没读明白, 到后来1天读10页, 进步很明显. 但不足的是读对话很快, 语法简单且没有太难的词汇, 而大段的论述读起来还是有些吃力, 有待提高. 这件事明年还会继续做.&lt;/p&gt;

&lt;h5&gt;史蒂夫.乔布斯传&lt;/h5&gt;

&lt;p&gt;作为一个技术工人, 多了解产品是很有帮助的, 这本书在这方面对我的帮助很大. 最深刻的应该是&lt;strong&gt;至繁归于至简&lt;/strong&gt;的设计理念了.&lt;/p&gt;

&lt;h5&gt;UNIX网络编程&lt;/h5&gt;

&lt;p&gt;只是把基本的搞明白了, socket, POSIX信号, I/O复用, I/O非阻塞, 线程等等. 还有很多东西以后要慢慢学习. 很遗憾没能写个程序实践, 这事放到明年做.&lt;/p&gt;

&lt;h5&gt;高性能MySQL&lt;/h5&gt;

&lt;p&gt;买这书本来是打算准备面试的, 结果书没看就走人了. 主要的收获肯定是关于索引, 在开发过程中设计和使用索引的收益非常大, 解决了很多. 开发时对于索引的不熟和忽视也吃到了一些苦头. 其它的还有存储引擎InnoDB/MyISAM, 分库分表, 复制, 扩展, 备份, Sphinx, Explain等. 以后遇到问题再随手翻吧.&lt;/p&gt;

&lt;h5&gt;普林斯顿-算法&lt;/h5&gt;

&lt;p&gt;这是一门在线学习的课程, 在coursera上. 完成第一期的全部视频课程, 并做了两个作业(程序)和课后的习题, 包括的知识点大概有并查集, 队列, 排序, 红黑树, 哈希表等.一是拱固了几个基本的算法,这对于面试(和被面试)非常有助. 二是练习了英语听力, 在学英语的道路上, 走出了非常重要的一步, 为后面的学习打下了基础.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://luxiaotong-image.stor.sinaapp.com/2014%E4%B9%A6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;关于做事&lt;/h4&gt;

&lt;hr&gt;

&lt;p&gt;业余时间做了这么两件事, 对开发和找工作起到了至关重要的帮助.
&lt;a href=&quot;http://comc.sinaapp.com/&quot; title=&quot;http://comc.sinaapp.com/&quot;&gt;http://comc.sinaapp.com/&lt;/a&gt;
&lt;a href=&quot;http://weeklydoc.cn/&quot; title=&quot;http://weeklydoc.cn/&quot;&gt;http://weeklydoc.cn/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;今年能到一家心仪已久的技术公司工作, 还是非常高兴的. 和小伙伴们相处的十分融洽, 多沟通少撕逼, 能够承担起责任, 协调各方, 推着项目往前走, 不是一件容易的事, 但是事后的成就是值得骄傲的.&lt;/p&gt;

&lt;p&gt;能够独自负责一个小系统并不断的解决遇到的问题, 进步非常快, 收获的知识也非常多. 主要有两件事印象十分深刻, 一是在开发过程对数据库的设计和使用, 极大的积累了在MySQL方面的经验和知识, 二是导数据的工作, 这丰富了我处理大量数据的开发和存储经验.&lt;/p&gt;

&lt;p&gt;最意外的是参加了一次校园招聘(面4人)和一次社招面试(面1人), 这极大的激发我在人才培养方面的兴趣, 希望以后能多参与面试, 能和不同的技术人员交流项目和技术很有意思, 这也不断的推动着我学习新知识.&lt;/p&gt;

&lt;p&gt;最重要的事: 提高技术, 解决问题, 开发项目.&lt;/p&gt;

&lt;p&gt;工作这么愉快不做点东西出来能行吗?&lt;/p&gt;

&lt;h4&gt;关于做人&lt;/h4&gt;

&lt;hr&gt;

&lt;p&gt;培养了几个好习惯, 十分受用. 管住嘴不乱说话, 俗话说祸从口出, 一张大嘴到处说话不知道得罪了多少人, 尽管有人觉得不爱说话不怎么好, 但是总比说错话得罪人强多了. 
先学做人, 再学做事, 有几件事对工作生活的帮助非常大, 所以放在这里说一下. 事看开点不较真, 心态很重要, 遇到不爽的人或事仍然能持续的沟通解决问题, 最终能达成目的才是关键. 做一个谦虚的人, 要学的东西真是非常多, 而且天外有天人外有人, 总有值得学习的东西. 到处吹牛逼的人见的太多了, 太能忽悠. 做人还是谦虚一点好. 做一个善良的好人, 我自认是有明辨是非能力的, 不因为别人说了或者做错了我也跟着错, 要时刻怀着善良的心, 另外也要有原则有底线, 不能为了钱忘记这些东西.
今年大半年一直在练柔术, 锻练身体的同时对我最大的帮助莫过于教我做人.一是培养自信, 见面和人握手, 说话时的眼神交流, 也不会胆小怕事. 二是坚持, 培养了强大的毅志品质, 做一个不轻易放弃的人, 有什么困难痛苦忍一忍就过去了. 对我生活和工作影响都非常大, 明年还会继续.   &lt;/p&gt;

&lt;h4&gt;关于2015&lt;/h4&gt;

&lt;hr&gt;

&lt;p&gt;明年有几个初步的计划, 有些不是很明确, 不知道会不会做, 有些一定会做, 一起说一说.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;完成一个UNIX网络编程相关的程序.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;学习Java, 开发Android. 这事本来是要买Mac开发IOS APP的, 但是明天9月可能出新本现在买有点亏, 而且学习Java为以后大数据或者其它什么别的都能用上, 所以把APP和Java结合在一起, 最终形成了Android的计划.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;学英语, 读原版书, 在Coursera上学习看视频.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;柔术, 不能停, 争取把泰拳和MMA加上.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;看书, 具体看什么在说吧.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;结语&lt;/h4&gt;

&lt;hr&gt;

&lt;p&gt;继续平淡的生活, 努力的学习工作, 锻练身体, 学做人完善自己.大概以后都是这样的吧. &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://luxiaotong-image.stor.sinaapp.com/%E9%81%93%E6%9C%8D.jpg&quot; alt=&quot;http://luxiaotong-image.stor.sinaapp.com/%E9%81%93%E6%9C%8D.jpg&quot;&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 31 Dec 2014 00:00:00 +0800</pubDate>
        <link>/2014%E6%80%BB%E7%BB%93/</link>
        <guid isPermaLink="true">/2014%E6%80%BB%E7%BB%93/</guid>
      </item>
    
      <item>
        <title>Linux中Vim和shell乱码解决</title>
        <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;问题: 使用Xshell连接到开发机, Vim和shell中的中文都出现乱码&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解决: &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Xshell编码改成UTF-8&lt;/li&gt;
&lt;li&gt;vim ~/.bash&lt;em&gt;profile, 增加一行:
`export LC&lt;/em&gt;ALL=en_US.utf8`&lt;/li&gt;
&lt;li&gt;source ~/.bash_profile&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;备注:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;由于没有sudo和root权限, 所以只能修改当前登录用户的~/.bash_profile, 如果有权限可以尝试修改/etc/sysconfig/i18n&lt;/li&gt;
&lt;li&gt;source的作用是把刚才修改的内容加载一下.否则修改完需要重启或重新登录.&lt;/li&gt;
&lt;li&gt;修改前可以使用locale -a, 查看当前支持的编码.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;参考:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/wangjun_pfc/article/details/4009205&quot; title=&quot;http://blog.csdn.net/wangjun_pfc/article/details/4009205&quot;&gt;http://blog.csdn.net/wangjun_pfc/article/details/4009205&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/Jack47/p/3551584.html&quot; title=&quot;http://www.cnblogs.com/Jack47/p/3551584.html&quot;&gt;http://www.cnblogs.com/Jack47/p/3551584.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 13 Jul 2014 00:00:00 +0800</pubDate>
        <link>/Linux%E4%B8%ADVim%E5%92%8Cshell%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3/</link>
        <guid isPermaLink="true">/Linux%E4%B8%ADVim%E5%92%8Cshell%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3/</guid>
      </item>
    
      <item>
        <title>关于sudo 的发音</title>
        <description>&lt;h3&gt;sudo在manual中的定义:&lt;/h3&gt;

&lt;p&gt;execute a command as another user
使用其它用户身份执行一个命令.&lt;/p&gt;

&lt;p&gt;sudo allows a permitted user to execute a command as the superuser or another user, as specified in the sudoers file.
sudo允许sudoers文件中指定的用户,使用超级用户或其它用户身份执行一个命令.&lt;/p&gt;

&lt;h3&gt;pseudo的单词释义&lt;/h3&gt;

&lt;p&gt;n. 伪君子；假冒的人
adj. 冒充的，假的&lt;/p&gt;

&lt;h3&gt;sudo与pseudo&lt;/h3&gt;

&lt;p&gt;sudo表达了一种假冒其它人执行命令的意思, 在意思上与pseudo很接近, 而且这两个单词也长的也很像, 所以我猜测sudo就是pseudo的缩写, 发音和pseudo一样.&lt;/p&gt;

&lt;h3&gt;发音&lt;/h3&gt;

&lt;p&gt;[&amp;#39;sʊdo] &lt;/p&gt;

&lt;h3&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://dict.youdao.com/search?q=pseudo&amp;amp;keyfrom=hao360&quot;&gt;http://dict.youdao.com/search?q=pseudo&amp;amp;keyfrom=hao360&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 11 Jul 2014 00:00:00 +0800</pubDate>
        <link>/%E5%85%B3%E4%BA%8Esudo%E5%8F%91%E9%9F%B3/</link>
        <guid isPermaLink="true">/%E5%85%B3%E4%BA%8Esudo%E5%8F%91%E9%9F%B3/</guid>
      </item>
    
  </channel>
</rss>